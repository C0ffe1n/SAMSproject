# -*- coding: utf-8 -*-
# Copyright (C) 2015-2016 Alexey Karyabkin.
# This file is part of System Analysis of eMail messageS (SAMS)
# See the file 'docs/LICENSE' for copying permission.

import hashlib
import os
import email
import mimetypes
import magic
import shutil
import re
import logging

from email.header import Header
from lib.exceptions import SAMSAnalysisError
from lib.futils import File
from lib.futils import GeoInfo
from lib.categoryfilters import ExtExecFilters
from lib.common.constants import SUSPECT_FTYPE_FLAG, INIT_DATA

log = logging.getLogger(__name__)

class MalwareManager():
    def __init__(self, cfg):
        self.cfg = cfg
        self.mta_domain = cfg.mta_domain.split(',')
        log.setLevel(logging.INFO)
        
    def initialize(self, task):
        self.sample = File(task['file'])
        self.file_path = task['file']
        self.profile_path = os.path.dirname(task['file'])
        self.sample_path = os.path.join(self.profile_path, 'sample')
        self.listf = []
        self.filesize = None
        self.hashes = []
        self.attach_hashes = []
        self.attach_ftype = dict()
        self.files_type = dict()
        self.attach_md5 = None
        self.attach_sha256 = None
        self.detailsb = None
        self.key_id = str(task['_id'])
        self.incotrs = None
        self.user = 'test'
        self.status = None
        self.report = None
        self.headers = None
        self.inIOC = False
        self.msg_data = None
        self.sender = None
        self.recipient = ''
        self.subject = ''
        self.uagent = ''
        self.ipmta = ''
        self.geo_mta = {}
        self.strings = []
        self.detailinfoTE = {}
        self.detailinfoVT = None
        self.detailinfoTH = {}
        self.trace_received = None
        self.path_file = ''
        self.verdict = INIT_DATA
        self.detect = 'undefined'
        self.LAV_result = None
        self.YA_result = None
        log.info('Initialize manager malware profile')


    def run(self, task):
        try:
            if self.proccessing(task):
                return True
            else:
                return False
        except SAMSAnalysisError as e:
            log.error('Processing failed: %s' % e)
            return False
        
    def proccessing(self, task):
        self.initialize(task)
        desc = ''
        try:
            for k in task['attachment']:
                self.path_file = os.path.join(self.profile_path, 'attachments', k['attach_name'])
                ext_ft = k['attach_name'].split('.')[-1]
                if self.attach_ftype.get(ext_ft.lower()) is None:
                    self.attach_ftype[ext_ft.lower()] = ext_ft.upper()
                self.attach_md5 = File(self.path_file).get_md5()
                self.attach_sha256 = File(self.path_file).get_sha256()
                self.attach_hashes.append({'md5': self.attach_md5, 'sha256': self.attach_sha256})
        except Exception as e:
            log.error('Processing failed: %s' % e)
            return False
        
        self.listf = self.get_list_file(os.path.join(os.path.dirname(task['file']), 'sample'))
        if len(self.listf) > 5:
            log.info('Limit exceeded file')
            return False
        else:
            _exe = ExtExecFilters()
            files_count = 0
            for fname in self.listf:
                attach_file = File(os.path.join(os.path.dirname(self.sample_path), fname))
                tmp = '\t'.join([attach_file.get_name(), attach_file.get_md5()])
                self.hashes.append({fname: attach_file.get_md5()})
                desc = desc+tmp+'\r\n'
                ext_ft = fname.split('.')[-1]
                if ext_ft in _exe.list:
                    files_count += 1
                if self.files_type.get(ext_ft.lower()) is None:
                    self.files_type[ext_ft.lower()] = ext_ft.upper()
        if files_count > 0:
            self.verdict = self.verdict | SUSPECT_FTYPE_FLAG

        self.report = desc.encode('utf-8')
        self.headers = self.get_header()
        self.geo_mta = {
                        'ip':self.ipmta,
                        'country_code': GeoInfo().get_country_code(self.ipmta),
                        'country_name': GeoInfo().get_country_name(self.ipmta)
                        }
        log.info(self.geo_mta)
        return True

    def filter_symbols(self, _str):
        f_str = _str
        for i in iter(['(',')','[',']']):
            f_str = f_str.replace(i,'')
        return f_str

    def parse_ip_domain(self, data, _id, key):
        struct_data = {}
        struct_data['id'] = _id
        key_ip = key+'_ip'
        key_domain = key+'_domain'
        key_data = key+'_data'
        _data = []
        _ip = []
        _domain_data = []
        if len(data) > 2:
            _data.append(data[0])
            _data.append(', '.join(data[1:]))
        else:
            _data = data
        i = 0
        for k in _data:
            i+=1
            sf = self.filter_symbols(k)
            pt_domain = '^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\.)+[a-z]{2,}$'
            pt_ip = '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$'
            domain_rexp = re.compile(pt_domain)
            ip_rexp = re.compile(pt_ip)
            if domain_rexp.match(sf) is None:
                if i == 1:
                    struct_data[key_ip] = sf
                else:
                    if ip_rexp.match(sf) is None:
                        struct_data[key_data] = sf
                    else:
                        struct_data[key_ip] = sf
            else:
                if i == 1:
                    struct_data[key_domain] = sf
                else:
                    if ip_rexp.match(sf) is None:
                        struct_data[key_data] = sf
                    else:
                        struct_data[key_ip] = sf
        return struct_data
        
    def get_trace_received(self, headers):
        trace = []
        i = 0
        for r in headers:
            d = r.split()
            struct_data = {}
            s = []
            i += 1
            for index, k in enumerate(d):
                if k == 'from':
                    continue
                elif k == 'by':
                    struct_data.update(self.parse_ip_domain(s, i,'from'))
                    s = []
                    continue
                elif k == 'with':
                    struct_data.update(self.parse_ip_domain(s, i, 'by'))
                    trace.append(struct_data)
                    break
                elif k == '(envelope-from':
                    continue
                elif k == 'for':
                    break
                else:
                    s.append(k)
        return trace
    
    def recipt_from_header(self, msg):
        header = msg.get_all('received')
        if header:
            for item in header:
                item = item.replace('\r\n',' ')
                if not re.search('.*for.*;', item) is None:
                    return item[item.find('for')+4:item.find(';')].strip()
        return ''
        
    def get_header(self):
        msg = self.msg_read()
        str_hr = self.normalize(msg.get('from'))
        self.sender = str_hr
        str_hr = self.normalize(msg.get('To'))
        if len(str_hr) < 2:
            if str_hr[0]['email'] == '':
                str_hr[0]['email'] = self.recipt_from_header(msg)
            else:
                str_hr.append({'email': self.recipt_from_header(msg), 'full_name': ''})

        self.recipient = str_hr
        self.subject = self.convert_str(msg.get('subject'))
        #X-Mailer: Microsoft Outlook 14.0 - useragent
        self.uagent = msg.get('User-Agent')
        dop = ' '.join(['From: ', self.sender[0]['full_name']+' ['+self.sender[0]['email']+']']) + '\r\n'
        dop = dop + 'To: '

        for k in self.recipient:
            dop = dop + k['full_name']+' ['+k['email']+'], '
        dop = dop+'\r\n'
        try:
            if not self.subject is None:
                dop = dop + 'Subject: '+ self.subject + '\r\n'
            else:
                dop = dop + 'Subject: None\r\n'
            ss = ''
        except:
            pass
        if not msg.get_all('received') is None:
            dop = dop + 'Received: ' + '\r\n'
            pattern = '^from.*\ by.*'
            p = re.compile(pattern)
            receiv_headrs = msg.get_all('received')
            self.trace_received = self.get_trace_received(receiv_headrs)
            for c in self.trace_received:
                try:
                    for k in self.mta_domain:
                        if'by_domain' in c:
                            if c['by_domain'].find(k)>=0: 
                                if ('from_ip' in c) and (c['from_ip']!= ''):
                                    self.ipmta = c['from_ip']
                                    break
                                elif ('from_data' in c) and (c['from_data']!= ''):
                                    self.ipmta = c['from_data']
                                    break
                                elif ('from_domain' in c) and (c['from_domain']!= '') and (c['from_domain'] != 'exim'):
                                    self.ipmta = c['from_domain']
                                    break
                        if self.ipmta != '':
                            break
                except Exception as e:
                    log.error('Processing header (MTA): %s' % e)   
            self.ipmta = self.ipmta.split(', ')[0]
            for r in receiv_headrs:
                dop = dop + r
        klms = msg.items()
        for key in klms:
            if 'X-KLMS' in key[0]:
                dop = dop+': '.join([key[0], key[1]])+'\r\n'
        return dop

    def get_list_file(self, path):
        listf = []
        dirlist = os.listdir(path)
        for sfile in dirlist:
            try:
                pp = os.path.join(path, sfile)
            except Exception as e:
                pp = sfile.decode('cp866')
                ss = pp.encode('utf-8')
                ss = os.path.join(path.encode('utf-8'), ss)
                pp = os.path.join(path, pp)
                shutil.move(pp.encode('cp866'), ss)
                pp = ss

            if os.path.isfile(pp):
                listf.append(pp)
            else:
                listf.extend(self.get_list_file(pp))
        return listf

    def get_msg_dozor(self, msg):
        tmp = msg.get_payload()
        return tmp[1].get_payload()

    def msg_read(self):
        sfile = open(self.file_path, 'r')
        msg = sfile.read()
        sfile.close()
        return self.get_msg_data(msg)

    def get_msg_data(self, msg_data):
        try:
            msg = email.message_from_string(msg_data)
            if 'dozor@dozor.ru' in msg.get('from'):
                msg = self.get_msg_dozor(msg)
                data = msg[0]
            else:
                data = msg
            return data
        except Exception as e:
            log.error('Processing failed: %s' % e)
            return None

    def normal_str(self, str, method):
        if method == 'base64':
            try:
                tmp = email.header.decode_header(str)
                if tmp[0][1]:
                    nstr = tmp[0][0].decode(tmp[0][1])
                else:
                    nstr = tmp[0][0]
            except:
                nstr = str
        else:
            nstr = str
        return nstr
    
    def normalize(self, str):
        if not str is None and not str is '':
            if 'undisclosed-recipients' in str:
                return [{'full_name':self.convert_str(str), 'email':''}]
            else:
                if str.find('>')> -1:
                    res = str[:-1]
                else: res = str

                if len(str.split('>,')) > 1:
                    mas = []
                    ttt = {}
                    for k in str.split('>,'):
                        tmp = k
                        tmp = tmp.replace('\r\n\t','')
                        tmp = tmp.replace('>','')
                        tmp = tmp.replace('<',' <')
                        rrr = tmp.split(' <')
                        if len(rrr) > 1:
                            ttt = {'full_name':self.convert_str(rrr[0]), 'email':self.convert_str(rrr[1])}
                        elif rrr[0].find('@')> -1:
                            ttt = {'full_name':'', 'email':self.convert_str(rrr[0])}
                        else:
                            ttt = {'full_name':self.convert_str(rrr[0]), 'email':''}
                        mas.append(ttt)
                    return mas
                elif res.find('<')> -1 and res.find('@')> -1:
                    res = res.replace('\r','')
                    res = res.replace('\n','')
                    res = res.replace('\t','')
                    res = res.replace('<',' <')
                    rrr = res.split(' <')
                    return [{'full_name':self.convert_str(rrr[0]), 'email':self.convert_str(rrr[1])}]
                elif res.find('@')> -1:
                    return [{'full_name':'', 'email':self.convert_str(res)}]
                else:
                    return [{'full_name':self.convert_str(res), 'email':''}]
        return [{'full_name':'', 'email':''}]
   
    def convert_str(self, strl):
        r_str = ''
        try:
            if not strl is None:
                p_strs = strl.strip()
                p_strs = p_strs.split('?=')
                sdf = False
                if len(p_strs) > 1:
                    sdf = True
                for item in p_strs:
                    if item != '':
                        if sdf:
                            dec_str = email.header.decode_header(item+'?=')
                        else:
                            dec_str = email.header.decode_header(item)
                        for s in dec_str:
                            if (not s[1] is None) and (s[1] != 'utf-8'):
                                r_str += '' + s[0].decode(s[1]).encode('utf-8','replace')
                            else:
                                r_str += '' + s[0]
        except Exception as e:
            if not strl is None:
                r_str = strl.decode('utf-8','replace')
            else:
                r_str = ''
            log.error('Processing failed: %s' % e)
        return r_str.strip()
