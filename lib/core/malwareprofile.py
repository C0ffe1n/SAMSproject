# -*- coding: utf-8 -*-
# Copyright (C) 2015-2016 Alexey Karyabkin.
# This file is part of System Analysis of eMail messageS (SAMS)
# See the file 'docs/LICENSE' for copying permission.

import hashlib
import os
import email
import mimetypes
import magic
import shutil
import re
import logging

from email.header import Header
from lib.exceptions import SAMSAnalysisError
from lib.futils import File
from lib.futils import GeoInfo
from lib.categoryfilters import ExtExecFilters
from lib.common.constants import SUSPECT_FTYPE_FLAG, INIT_DATA

log = logging.getLogger(__name__)

class MalwareManager():
    def __init__(self, cfg):
        self.cfg = cfg
        self.mta_domain = cfg.mta_domain.split(',')
        log.setLevel(logging.INFO)
        
    def initialize(self, task):
        self.sample = File(task['file'])
        self.file_path = task['file']
        self.profile_path = os.path.dirname(task['file'])
        self.sample_path = os.path.join(self.profile_path, 'sample')
        self.listf = []
        self.filesize = None
        self.hashes = []
        self.attach_hashes = []
        self.attach_ftype = dict()
        self.files_type = dict()
        self.attach_md5 = None
        self.attach_sha256 = None
        self.detailsb = None
        self.key_id = str(task['_id'])
        self.incotrs = None
        self.user = 'test'
        self.status = None
        self.report = None
        self.headers = None
        self.inIOC = False
        self.msg_data = None
        self.sender = None
        self.recipient = ''
        self.subject = ''
        self.uagent = ''
        self.ipmta = ''
        self.geo_mta = {}
        self.strings = []
        self.detailinfoTE = {}
        self.detailinfoVT = None
        self.detailinfoTH = {}
        self.trace_received = None
        self.path_file = ''
        self.verdict = INIT_DATA
        self.detect = 'undefined'
        self.LAV_result = None
        self.YA_result = None
        log.info('Initialize manager malware profile')


    def run(self, task):
        try:
            if self.proccessing(task):
                return True
            else:
                return False
        except SAMSAnalysisError as e:
            log.error('Processing failed: %s' % e)
            return False
        
    def proccessing(self, task):
        self.initialize(task)
        desc = ''
        try:
            for k in task['attachment']:
                self.path_file = os.path.join(self.profile_path, 'attachments', k['attach_name'])
                ext_ft = k['attach_name'].split('.')[-1]
                if self.attach_ftype.get(ext_ft.lower()) is None:
                    self.attach_ftype[ext_ft.lower()] = ext_ft.upper()
                self.attach_md5 = File(self.path_file).get_md5()
                self.attach_sha256 = File(self.path_file).get_sha256()
                self.attach_hashes.append({'md5': self.attach_md5, 'sha256': self.attach_sha256})
        except Exception as e:
            log.error('Processing failed: %s' % e)
            return False
        
        self.listf = self.get_list_file(os.path.join(os.path.dirname(task['file']), 'sample'))
        if len(self.listf) > 5:
            log.info('Limit exceeded file')
            return False
        else:
            _exe = ExtExecFilters()
            files_count = 0
            for fname in self.listf:
                attach_file = File(os.path.join(os.path.dirname(self.sample_path), fname))
                tmp = '\t'.join([attach_file.get_name(), attach_file.get_md5()])
                self.hashes.append({fname: attach_file.get_md5()})
                desc = desc+tmp+'\r\n'
                ext_ft = fname.split('.')[-1]
                if ext_ft in _exe.list:
                    files_count += 1
                if self.files_type.get(ext_ft.lower()) is None:
                    self.files_type[ext_ft.lower()] = ext_ft.upper()
        if files_count > 0:
            self.verdict = self.verdict | SUSPECT_FTYPE_FLAG

        self.report = desc.encode('utf-8')
        self.headers = self.get_header()
        self.geo_mta = {
                        'ip':self.ipmta,
                        'country_code': GeoInfo().get_country_code(self.ipmta),
                        'country_name': GeoInfo().get_country_name(self.ipmta)
                        }
        log.info(self.geo_mta)
        return True

    def filter_symbols(self, _str):
        f_str = _str
        for i in iter(['(',')','[',']']):
            f_str = f_str.replace(i,'')
        return f_str

    def parse_ip_domain(self, data, _id, key):
        struct_data = {}
        struct_data['id'] = _id
        key_ip = key+'_ip'
        key_domain = key+'_domain'
        key_data = key+'_data'
        _data = []
        _ip = []
        _domain_data = []
        if len(data) > 2:
            _data.append(data[0])
            _data.append(', '.join(data[1:]))
        else:
            _data = data
        i = 0
        for k in _data:
            i+=1
            sf = self.filter_symbols(k)
            pt_domain = '^([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*\.)+[a-z]{2,}$'
            pt_ip = '^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$'
            domain_rexp = re.compile(pt_domain)
            ip_rexp = re.compile(pt_ip)
            if domain_rexp.match(sf) is None:
                if i == 1:
                    struct_data[key_ip] = sf
                else:
                    if ip_rexp.match(sf) is None:
                        struct_data[key_data] = sf
                    else:
                        struct_data[key_ip] = sf
            else:
                if i == 1:
                    struct_data[key_domain] = sf
                else:
                    if ip_rexp.match(sf) is None:
                        struct_data[key_data] = sf
                    else:
                        struct_data[key_ip] = sf
        return struct_data
        
    def get_trace_received(self, headers):
        trace = []
        i = 0
        for r in headers:
            d = r.split()
            struct_data = {}
            s = []
            i += 1
            for index, k in enumerate(d):
                if k == 'from':
                    continue
                elif k == 'by':
                    struct_data.update(self.parse_ip_domain(s, i,'from'))
                    s = []
                    continue
                elif k == 'with':
                    struct_data.update(self.parse_ip_domain(s, i, 'by'))
                    trace.append(struct_data)
                    break
                elif k == '(envelope-from':
                    continue
                elif k == 'for':
                    break
                else:
                    s.append(k)
        return trace
    
    def recipt_from_header(self, msg):
        header = msg.get_all('received')
        if header:
            for item in header:
                item = item.replace('\r\n','')
                item = item.replace('\t',' ')
                if not re.search('.*\ for\ .*;', item) is None:
                    return item[item.find(' for ')+4:item.find(';')].strip()
        return ''
        
    def get_header(self):
        msg = self.msg_read()
        self.subject = self.normalize(msg.get('subject'))
        self.sender = self.get_addr_values(msg.get_all('from', []))
        str_hr = self.get_addr_values(msg.get_all('to', []))
        if len(str_hr) < 2:
            if str_hr[0]['email'] == '':
                str_hr[0]['email'] = self.recipt_from_header(msg)
            else:
                str_hr.append({'email': self.recipt_from_header(msg), 'full_name': ''})

        self.recipient = str_hr
        #self.subject = self.convert_str(msg.get('subject'))
        #X-Mailer: Microsoft Outlook 14.0 - useragent
        self.uagent = msg.get('User-Agent')
        dop = ' '.join(['From: ', self.sender[0]['full_name']+' ['+self.sender[0]['email']+']']) + '\r\n'
        dop = dop + 'To: '

        for k in self.recipient:
            dop = dop + k['full_name']+' ['+k['email']+'], '
        dop = dop+'\r\n'
        try:
            if not self.subject is None:
                dop = dop + 'Subject: '+ self.subject + '\r\n'
            else:
                dop = dop + 'Subject: None\r\n'
            ss = ''
        except:
            pass
        if not msg.get_all('received') is None:
            dop = dop + 'Received: ' + '\r\n'
            pattern = '^from.*\ by.*'
            p = re.compile(pattern)
            receiv_headrs = msg.get_all('received')
            self.trace_received = self.get_trace_received(receiv_headrs)
            for c in self.trace_received:
                try:
                    for k in self.mta_domain:
                        if'by_domain' in c:
                            if c['by_domain'].find(k)>=0: 
                                if ('from_ip' in c) and (c['from_ip']!= ''):
                                    self.ipmta = c['from_ip']
                                    break
                                elif ('from_data' in c) and (c['from_data']!= ''):
                                    self.ipmta = c['from_data']
                                    break
                                elif ('from_domain' in c) and (c['from_domain']!= '') and (c['from_domain'] != 'exim'):
                                    self.ipmta = c['from_domain']
                                    break
                        if self.ipmta != '':
                            break
                except Exception as e:
                    log.error('Processing header (MTA): %s' % e)   
            self.ipmta = self.ipmta.split(', ')[0]
            for r in receiv_headrs:
                dop = dop + r
        klms = msg.items()
        for key in klms:
            if 'X-KLMS' in key[0]:
                dop = dop+': '.join([key[0], key[1]])+'\r\n'
        return dop

    def get_list_file(self, path):
        listf = []
        dirlist = os.listdir(path)
        for sfile in dirlist:
            try:
                pp = os.path.join(path, sfile)
            except Exception as e:
                pp = sfile.decode('cp866')
                ss = pp.encode('utf-8')
                ss = os.path.join(path.encode('utf-8'), ss)
                pp = os.path.join(path, pp)
                shutil.move(pp.encode('cp866'), ss)
                pp = ss

            if os.path.isfile(pp):
                listf.append(pp)
            else:
                listf.extend(self.get_list_file(pp))
        return listf

    def get_msg_dozor(self, msg):
        tmp = msg.get_payload()
        return tmp[1].get_payload()

    def msg_read(self):
        sfile = open(self.file_path, 'r')
        msg = sfile.read()
        sfile.close()
        return self.get_msg_data(msg)

    def get_msg_data(self, msg_data):
        try:
            msg = email.message_from_string(msg_data)
            if 'dozor@dozor.ru' in msg.get('from'):
                msg = self.get_msg_dozor(msg)
                data = msg[0]
            else:
                data = msg
            return data
        except Exception as e:
            log.error('Processing failed: %s' % e)
            return None

    def normal_str(self, text, default='ascii'):
        buf = []
        for item in text.split('\r\n'):
            item = item.replace(':;','')
            item = item.replace('<','')
            item = item.replace('>','')
            header = email.header.decode_header(item.strip())
            for i, (text, charset) in enumerate(header):
                try:
                    buf.append(unicode(text, charset or default, errors='replace'))
                except LookupError:
                    buf.append(unicode(text, default, errors='replace'))
        return u''.join(buf)
    
    def get_addr_values(self, data):
        addr_list = []
        if data:
            addr_list_raw = email.utils.getaddresses(data)
            if len(addr_list_raw)!=0:
                for item in addr_list_raw:
                    if item[0]=='' and item[1]=='':
                        addr_list.append({'full_name':self.normal_str(data[0]), 'email':''})
                    else:
                        addr_list.append({'full_name':self.normal_str(item[0]), 'email':item[1]})
            else:
                addr_list.append({'full_name':'', 'email':''})            
        else:
            addr_list.append({'full_name':'', 'email':''})
        return addr_list
   
    def normalize(self, data, default="ascii"):
        buf = []
        if data:
            for item in data.split('\r\n'):
                for i, (text, charset) in enumerate(email.header.decode_header(item.strip())):
                    buf.append(unicode(text, charset or default, errors='replace'))
        return u''.join(buf)

    def convert_str(self, strl, default="ascii"):
        r_str = u''
        try:
            if not strl is None:
                p_strs = strl.strip()
                p_strs = p_strs.split('?=')
                splitf = False
                if len(p_strs) > 1:
                    splitf = True
                for item in p_strs:
                    if item != '':
                        if splitf:
                            dec_str = email.header.decode_header(item+'?=')
                        else:
                            dec_str = email.header.decode_header(item)
                        for i, (text, charset) in enumerate(dec_str):
                            r_str += u''.join(unicode(text, charset or default, errors='replace'))
        except LookupError as e:
            log.error('Processing failed: %s' % e)
        return r_str.encode('utf-8')
